# ABC
1. Python文化中的接口和协议
    * 协议是实现特定角色的方法集，而一个类可以实现多个协议（接口），扮演多个角色
    * 协议: 非正式的接口
        * 类与协议（隐式或者说是假隐式: 标准库中的抽象基类）: 迭代协议、序列协议
            * 标准库中的抽象基类有哪些？collections.abc
                * Iterable
                    * Iterator
                * Container
                    * Sequence
                        * MutableSequence
                    * Mapping
                        * MutableMapping
                    * Set
                        * MutableSet
                    * Sized
            * 如何实现某个协议？只要实现某个方法即可（不需要显式继承，和go中的interface差不多）
            * Python喜欢序列，序列协议是Python最基础的协议之一
                * 如果没有实现__iter__和__contains__，python会设法调用__getitem__
                * Python哲学：尽量支持基本协议
        ```python
        class Struggle:
            def __len__(self): # 抽象基类是标准库中的abc.Sized，不需要显式继承
                return 23

        from collections import abc
        isinstance(Struggle(), abc.Sized)
        ```
        * 类与抽象基类（显式）
            * 如果类的基类是抽象基类，必须实现所有抽象方法，否则会报错
                * 抽象基类和go的interface一样，定义了方法集
                * 不过，go实现interface是隐式的，而python显示继承了
            * 和协议的区别？协议是标准库中的抽象基类
                * 感觉上协议是内置的、特殊的、无需继承的抽象基类，并且 __功能__ 强大
                * 我们自己定义的抽象基类，更像一种 __约束__，功能上需要自己去实现，并没有像协议这么强大
            * 抽象基类有啥用？
                * 代码约束: 子类如果没有实现方法会报TyperError
                * 让协议(接口)具象化（更加明确地表示实现了哪些方法，就实现了抽象基类）
            * 标准库中的抽象基类和自己实现的抽象基类的区别
                * 如果是标准库中的抽象基类(其实就是我上面写的协议)，只需要实现对应的方法就行了（隐式继承）
                * 自定义的抽象基类，必须要显式继承，并且必须实现抽象方法
                * 为什么区别对待？标准库中的抽象基类比较少，方法比较固定，所以通过方法就可以找到
                    * 如何判断是否实现了某个抽象基类？
        * 类与父类（协议和抽象基类更像一种规范，类和父类则是一种关系）
            * 继承父类的方法
                * __Mixin__: 混入类，虽然也是继承方法，但不是继承的关系，更像工具集，是一种 __组合__ 关系（优先使用组合而不是继承）
                * Mixin是一种语言概念，允许程序员将代码注入到类中（在类名中明确表示Mixin）
            * 重写父类的方法
            * 子类最多一个父类，其他的类都应该是抽象基类、混入类
            * 把接口继承和实现继承区分开（抽象基类中只包含抽象方法，为了规范接口；混入类中只包含具体实现，为了重用代码）
            ```python
            class A(B, CMixin, DMixin):
                ...
            ```
