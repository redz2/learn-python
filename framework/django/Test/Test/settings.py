"""
Django settings for Test project.

Generated by 'django-admin startproject' using Django 5.0.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-_167eu^o7+cj+^sp%ff+k-ucpfdpv#ja)ec5x2@m8(ph0ziiti'

# SECURITY WARNING: don't run with debug turned on in production!
# DEBUG = True
DEBUG = True

# 为什么关闭DEBUG后，static样式找不到了？
ALLOWED_HOSTS = ['*']


# Application definition

# 查找models
# 查找static
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth', # Admin管理后台登录、登出、修改密码等
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',  # 仅在DEBUG模式下有用，生产环境就找不到静态文件了
    
    # 第三方的app
    'rest_framework',
    'django_filters', # 使用django-filter实现列表接口的查询过滤
    # 'coreapi', # 接口文档 
    # 'drf_yasg', # 接口文档 Swagger -> OpenAPI

    # 自己开发的app
    'apps.api.apps.ApiConfig',
    'apps.nodrf.apps.NodrfConfig', # 不使用drf
    'apps.drf.apps.DrfConfig', # 使用drf
    'apps.req.apps.ReqConfig', # APIView
    'apps.components.apps.ComponentsConfig',
]

# 中间件
MIDDLEWARE = [
    # 执行顺序
    # 前处理的顺序从上到下
    # 后处理的顺序从下到上
    
    # django自带的中间件
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',    # 获取request.COOKIES的值 -> 放到request.session中
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    
    # 登录用户 -> request.user = <class 'django.utils.functional.SimpleLazyObject'>
    'django.contrib.auth.middleware.AuthenticationMiddleware', # 通过session id查找用户 -> 放到request.user中
    'django.contrib.messages.middleware.MessageMiddleware',
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
    
    # 自定义的中间件
    'apps.middleware.md.TestMiddleware',
    'apps.middleware.md.BasicMiddleware',
]

ROOT_URLCONF = 'Test.urls'

# 不知道有啥用
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'Test.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases


# django 支持项目连接多个数据库，读写分离
DATABASE_ROUTERS = ["apps.utils.dbrouter.demo_db_router.DemoRouter"]

# python manage.py migrate --database=default
import pymysql
pymysql.install_as_MySQLdb()

DATABASES = {
    'default': {
        # 默认：文件类数据库
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# 为什么需要连接池？
# 避免重复创建连接，关闭连接，减少性能损耗


# django默认没有数据库连接池的功能
# pymsql  ---> 操作数据库
# DBUtils ---> 连接池 django-db-connection-pool，底层使用支持SQLAchemy数据库连接池

# DATABASES = {
#     "bak":{
#         'ENGINE': 'dj_db_conn_pool.backends.mysql',
#         'NAME':'xxx',
#         'USER': 'root',
#         'PASSWORD': 'root123',
#         'HOST':'127.0.0.1', 
#         'PORT' : 3306,
#         'POOL OPTIONS':{
#             'POOL_SIZE':10, # 最小
#             'MAX_OVERFLOW': 10, # 在最小的基础上,还可以增加10个,即:最大20个。
#             'RECYCLE': 24 * 60, # 连接可以被重复用多久,超过会重新创建,-1表示永久。
#             'TIMEOUT': 30, # 池中没有连接最多等待的时间。  
#         }
#     }
# }



# django setting中的代码被执行了两次
# 1，加载和执行初始化代码
# 2，启动服务器的阶段
# import os
# if os.environ.get('RUN_MAIN') != 'true':
#     print("第一次执行")
# else:
#     print("第二次执行")

# django只提供了引擎，如果要连接数据库还需要安装第三方库
# pymsql
# mysqlclient
# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.mysql',
#         'NAME':'xxxxxxxx',
#         'USER': 'root',
#         'PASSWORD': 'root123',
#         'HOST':'127.0.0.1',
#         'PORT': 3306,
#     }
# }



# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'zh-hans'

TIME_ZONE = 'Asia/Shanghai'

USE_I18N = True

USE_TZ = True

# get_user_model() 为什么知道用户模型是哪个？
# AUTH_USER_MODEL ='myapp.CustomUser'

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


APPEND_SLASH = True

########################################################################################################################


# REST_FRAMEWORK字典的内容是属于drf独有的配置项，与django的配置项进行区分
REST_FRAMEWORK = {
    # drf框架中的APIView内部会走认证源码
    "UNAUTHENTICATED_USER": None, # 未认证用户设置为None
    "UNAUTHENTICATED_TOKEN": None,
    # 解析器
    # 使用请求头中的Content-Type来自动解析参数，使用request.data获取即可
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.FormParser',
        'rest_framework.parsers.MultiPartParser',
    ],
    # 渲染器
    # 可以根据请求头中的Accept参数来自动渲染前端需要的数据格式
    'DEFAULT_RENDERER_CLASSES': (  
        'rest_framework.renderers.JSONRenderer',  # json渲染器，返回json数据
        'rest_framework.renderers.BrowsableAPIRenderer',  # 浏览器API渲染器，返回api调试界面
    ),
    # 
    # 全局认证类配置（常用认证方式: cookie，session，token）
    # drf按照列表顺序尝试每种认证方法，直到找到一个成功的认证或者尝试完所有认证
    'DEFAULT_AUTHENTICATION_CLASSES': [
        # 可以添加自定义认证类，返回(User, None)表示认证成功
        'rest_framework.authentication.SessionAuthentication', # session认证
        'rest_framework.authentication.BasicAuthentication' # Basic认证，基于账号密码
    ],
    # 全局权限类配置
    'DEFAULT_PERMISSION_CLASSES': [
        # 可以添加自定义权限类，返回False表示没有权限访问
        # 'rest_framework.permissions.AllowAny', # AllowAny: 表示允许任何用户访问站点视图，一般登录接口任何人都可以访问
        # IsAuthenticated: 登录用户才能访问
        # IsAdminUser: 仅管理员用户
        'rest_framework.permissions.IsAuthenticatedOrReadOnly'  # 已经登录的用户可以增删改查，未登录只能查看
    ],
    # 全局限流配置
    'DEFAULT_THROTTLE_CLASSES': [ # 限流类配置
        # 'rest_framework.throttling.AnonRateThrottle', # 未认证的用户，使用IP区分用户
        # 'rest_framework.throttling.UserRateThrottle', # 已登录用户，使用User区分用户
        # 'rest_framework.throttling.ScopedRateThrottle' # 以视图作为识别单位进行限流
    ],
    # 访问频率的全局配置
    # 支持 second、minute、hour、day
    'DEFAULT_THROTTLE_RATES': { # 频率配置
        # 'anon': '2/min', # 针对匿名用户，drf只识别首字母，写全是方便
        # 'user': '5/m', # 针对登录用户
        # 'Students': '50/h' # 
    },
    # 设置全局过滤器类和排序类（针对列表）
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend', # 过滤
        'rest_framework.filters.OrderingFilter', # 排序
    ],
    # 全局分页配置（影响所有列表页）
    # 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination', # limit 和 offset
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', # 页码
    # 如何自定义分页器？
    # 在drf中，总要使用ListModelMixin的list()，都会自动分页
    # 如果大部分需要分页，少部分APIView中设置 pagination_class = None
    'PAGE_SIZE': 2, # 如果不设置，表示没有进行分配
    
    # 处理drf框架中的其他异常
    'EXCEPTION_HANDLER': 'apps.components.errhandle.custom_exception_handler',
    
    # swagger组件相关
    # 'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.AutoSchema',

}

