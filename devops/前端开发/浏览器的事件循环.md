* 浏览器的进程模型
    1. 何为进程？房子 === 内存
    2. 何为线程？工人
    3. 浏览器是一个多进程多线程的应用程序
        * 浏览器进程
            * 页面显示、子进程管理、用户交互
        * 网络进程
        * 渲染进程（一个标签页一个渲染进程）
            * 渲染主线程，负责执行html、css、js代码
            * 计时线程
* 渲染主线程是如何工作的？
    1. 解析html
    2. 解析css
    3. 计算样式
    4. 布局
    5. 处理图层
    6. 每秒把页面画60次
    7. 执行js
    8. 执行事件处理
    9. 执行计时器的回调函数
* 思考题: 为什么渲染线程不开多个线程呢？
    * DOM一致性
    * 
* 若干解释？
    * 如何调度任务？
        * 正在执行一个js代码，用户点击了按钮，怎么办？不会处理
        * 正在执行一个js代码，计时器到时间了，怎么办？不会处理
        * 用户点击了按钮，计时器又到时间了，怎么办？队列顺序
    * 主线程想了个办法：排队
        * 事件循环（消息循环）
        * 主线程（无限循环 -> 任务队列获取任务 -> 执行任务 -> 创建新任务）
        * 其他线程，包括其他进程的线程（用户点击）-> 创建新任务
        * 其他线程（计时线程）-> 创建新任务
        * 特殊任务：渲染页面
    * 何为异步？（主线程不能阻塞，就绪后找时机处理这些事情）
        1. 计时完成
        2. 网络通信
        3. 用户操作
    * 如何理解JS的异步？
    ```
    JS是一门单线程语言，运行在浏览器的渲染主线程中，而渲染主线程只有一个（承担很多工作，渲染页面，执行js）
    如果采用同步的方式，极有可能导致主线程阻塞，消息队列中很多任务无法得到执行，一方面主线程白白消耗时间，一方面用户觉得卡

    所以浏览器采用异步方法来避免，具体做法是当某些任务放生时，比如计时器、网络、事件监听，主线程将任务交给其他现成去处理，自己立即结束任务
    当其他线程执行完成，将实现传递的回调函数包装成任务，加入到事件队列中，等待主线程执行
    ```
    * 为何JS会阻碍渲染？
    ```
    # 死循环指定时间
    # 死循环和setInterval的区别
    function delay(duration){
        var start = Date.now()
        while (Date.now() - start < duration){}
    }

    # 让交互线程监听按钮点击事件
    # 用户点击 -> 把函数放到消息队列中 -> 主线程发现有任务开始执行 -> 设置变量，进入死循环
    # 虽然文本已经变化了，绘制任务无法执行
    btn.onclick = function (){
        h1.textContent = "something changed"
        delay(3000)
    }
    ```
    * 任务有优先级吗？
        * 任务没有优先级，但是消息队列有优先级
        * 延时队列（中）
        * 交互队列（高）
        * 微队列（最高）-> 比绘制优先级还高
            1. Promise
            2. MutationObserver 
        ```
        # 全局JS代码
        setTimeout(function(){
            console.log(1)
        })
        Promise.resolve().then(function(){
            console.log(2)
        })
        delay(3000)
        console.log(3)

        3 -> 2 -> 1
        ```

        ```
        function addDelay(){
            console.log("添加延时队列")
            setTimeout(()=>{
                console.log("延时队列执行")
            }, 1000)
        }

        function addInteraction(){
            console.log("添加交互队列")
            interaction.onclick = ()=> {
                console.log("交互队列执行")
            }
            # 你有时间反应区点击按钮，保证全局JS代码执行完成前，任务已经添加到延时队列和交互队列中
            # 才能看出主线程如何挑选下一个任务
            delay(3000)
        }

        btn.onclick = ()=> {
            # 添加延时队列
            addDelay()
            # 添加交互队列
            addInteraction()
        }
        ```
    * 什么是JS的事件循环？
    ```
    消息循环，是浏览器渲染主线程的工作方式
    开启一个不会结束的for循环，每次从消息队列中取出一个任务执行
    ```
    * Js中的计时器能做到精确计时吗？
    ```
    不能。
    计时器的回调函数，只能在主线程空闲的时候执行
    ```

* 总结（如果无法开启多线程，如何来处理多个任务？最关键的是不能阻塞主线程）
    1. 单线程是异步产生的原因
    2. 事件循环是异步的实现方式