# Python编程思想
1. 基本的程序设计模式(IPO)
    * input -> process（模块化设计，拆分成更小的IPO）-> output
2. 解决复杂问题的有效方法（自顶向下）
    * 模块化设计
        * 抽象出关键的数据结构
            * 数据输入 -> 抽象基类
            * 逻辑处理 -> 中间过程数据抽象基类
                * 分层缺失: 各种功能写在一个类里
            * 数据输出 -> 抽象基类
3. 编程思想
    * 结构化
    * 关注点分离
    * 抽象
        * 优雅的编程始于抽象（无需关注实现细节，基于提供的抽象来构建应用）
        * 在合适的抽象上去思考问题（如果有人给你提供了抽象，你就得按照人家的规定来使用，不然就有点不识好歹了，除非你牛逼自己去实现）
    * 封装
        * 封装是抽象的实现形式
        * 将功能封装成python的模块或golang的包（工具库 or 层次结构）
    * 复用
        * 没有封装就没有复用
    * 分治
        * 如果一个问题无法解决，尝试分解问题（如何解决一个问题？）
    * 组合
        * 单一逻辑能够处理的问题有限，需要组合起来
    * 缓存
    * 解耦
        * 高内聚，低耦合
4. FP or OOP
    * FP: 更适合处理无状态的少量数据，单一流程
        * 变量不可变 -> 无状态 -> 更适合执行并发操作
        * 少量的数据，大量的简短函数，很容易添加新的函数
        * 但是如果要添加数据，就很费劲
    * OOP: 更适合处理有状态的数据，复杂的数据
        * 数据和操作绑定
        * 有状态 -> 方法带来副作用(状态改变) -> 更适合和实际生活中的场景联系起来 -> 容易看懂
        * 如果一个概念，必须包含多个接口才完整，没有理由分离成一个个函数
    * 应该更关注数据还是更关注流程？
        * 简单场景我认为用FP
        * 复杂场景我认为需要将大量函数组合，使用OOP
            * OOP我认为还能起到封装、组合的作用
```python
# 函数的不可变性: 不依赖于外部状态，不会产生副作用（函数式编程应该就是这样，更适合并发场景）

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # oop本质上就是`有状态`的函数式编程
    # 数据和方法绑定，方法可以修改数据，通过self参数给方法传递数据
    # 闭包，我认为也是一种OOP的思想，让函数有状态（当函数调用会产生副作用，就可以认为是有状态的）
    def age_plus_one(self):
        self.age += 1
```
